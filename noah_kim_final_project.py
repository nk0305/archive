# -*- coding: utf-8 -*-
"""Noah Kim - Final Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NGdw_S86KbmUPq1WK9iYQPGz2dnQ9WXo

Link to dataset: https://archive.ics.uci.edu/dataset/602/dry+bean+dataset
"""

import pandas as pd
import requests
import io

#Import the dataset
file_url = "https://drive.google.com/file/d/1-2WDny3wVt_Hm3l21YIpzM2a4poYv29p/view?usp=drive_link"
file_id = file_url.split("/")[-2]

url = f"https://drive.google.com/uc?id={file_id}&export=download"
response = requests.get(url)
content = response.content

bean = pd.read_csv(io.StringIO(content.decode('utf-8')))
bean

#Remove ambiguous attributes; modify the dataset
bean.drop(['ShapeFactor1', 'ShapeFactor2', 'ShapeFactor3', 'ShapeFactor4'], axis = 'columns')
bean.dropna()

#Show the information of the dataset, such as the number of entries and columns with their data types
bean.info()

#Split feature and label dataset
from sklearn.preprocessing import LabelEncoder
LE = LabelEncoder()
target = LE.fit_transform(bean['Class'])

X = bean.drop(['Class','ShapeFactor1', 'ShapeFactor2', 'ShapeFactor3', 'ShapeFactor4'], axis=1)
y = bean['Class'].to_numpy()

import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score

#Split the dataset into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

#Create a Random Forest model using bootstrapped samples
num_trees = 100
rf_model = RandomForestClassifier(n_estimators=num_trees, bootstrap=True, max_samples=0.8, random_state=42)

#Train the model on the training data
rf_model.fit(X_train, y_train)

#Evaluate the model on the testing data
y_pred = rf_model.predict(X_test)

#Calculate accuracy
accuracy = accuracy_score(y_test, y_pred)
print("Random Forest Accuracy:", accuracy)

from sklearn.metrics import confusion_matrix

#Create a function to evaluate the model
def evaluate_model(model, X_test, y_test):
    y_pred = model.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    confusion = confusion_matrix(y_test, y_pred)
    return accuracy, confusion

#Evaluation for Random Forest
RF_accuracy, RF_confusion = evaluate_model(rf_model, X_test, y_test)

#Print the accuracies and confusion matrices
print("RF - Accuracy:", RF_accuracy)
print("RF - Confusion Matrix:")
print(RF_confusion)

import matplotlib.pyplot as plt
import seaborn as sns

#Visualization of confusion matrix
sns.heatmap(RF_confusion, annot=True, fmt="d", cmap="PuBuGn")
plt.xlabel("Predicted Label")
plt.ylabel("True Label")
plt.title("Confusion Matrix")
plt.show()

#Calculate accuracy
accuracies = []
for estimator in rf_model.estimators_:
    y_pred_tree = estimator.predict(X_test)
    accuracy_tree = accuracy_score(y_test, y_pred_tree)
    accuracies.append(accuracy_tree)

#Print accuracy
for tree_num, accuracy_tree in enumerate(accuracies, 1):
    print(f"Tree {tree_num} Accuracy: {accuracy_tree}")

#Create function to get user input for prediction
def get_user_input():
    Area = float(input("Area: "))
    Perimeter = float(input("Perimeter: "))
    MajorAxisLength = float(input("Major axis length: "))
    MinorAxisLength = float(input("Minor axis length: "))
    AspectRation = float(input("Aspect ratio: "))
    Eccentricity = float(input("Eccentricity: "))
    ConvexArea = float(input("Convex area: "))
    EquivDiameter = float(input("Equivalent diameter: "))
    Extent = float(input("Extent: "))
    Solidity = float(input("Solidity: "))
    roundness = float(input("Roundness: "))
    Compactness = float(input("Compactness: "))
    user_data = pd.DataFrame({
        'Area': [Area],
        'Perimeter': [Perimeter],
        'MajorAxisLength': [MajorAxisLength],
        'MinorAxisLength': [MinorAxisLength],
        'AspectRation': [AspectRation],
        'Eccentricity': [Eccentricity],
        'ConvexArea': [ConvexArea],
        'EquivDiameter': [EquivDiameter],
        'Extent': [Extent],
        'Solidity': [Solidity],
        'roundness': [roundness],
        'Compactness': [Compactness]
    })
    return user_data

#Create function to predict
def predict_diagnosis(user_data):
    rf_prediction = rf_model.predict(user_data)
    return rf_prediction[0],

#Get user input and predict
user_data = get_user_input()
rf_pred = predict_diagnosis(user_data)

#Print the prediction
print("RF - Prediction:", rf_pred)